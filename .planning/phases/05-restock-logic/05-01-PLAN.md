---
phase: 05-restock-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - utilities/src/main/java/utilities/loadout/RestockResult.java
  - utilities/src/main/java/utilities/loadout/MissingItem.java
  - utilities/src/main/java/utilities/loadout/LoadoutComparator.java
autonomous: true
---

<objective>
Create the restock result data structure and comparison logic.

Purpose: Enable scripts to understand what items are missing from a loadout and track restock outcomes.
Output: RestockResult, MissingItem classes, and LoadoutComparator for diff calculation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-restock-logic/05-CONTEXT.md

@utilities/src/main/java/utilities/loadout/Loadout.java
@utilities/src/main/java/utilities/loadout/LoadoutItem.java
@utilities/src/main/java/utilities/loadout/QuantityMode.java
@utilities/src/main/java/utilities/items/ItemResolver.java
@utilities/src/main/java/utilities/items/ItemVariantMap.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MissingItem and RestockResult data classes</name>
  <files>utilities/src/main/java/utilities/loadout/MissingItem.java, utilities/src/main/java/utilities/loadout/RestockResult.java</files>
  <action>
Create two immutable data classes:

**MissingItem.java:**
- Fields: LoadoutItem loadoutItem, int currentQuantity, int neededQuantity, ContainerType container (enum: EQUIPMENT, INVENTORY, RUNE_POUCH, BOLT_POUCH, QUIVER)
- Getter methods for all fields
- getDeficit() returns neededQuantity - currentQuantity
- toString() for logging

**RestockResult.java:**
- Fields: List<MissingItem> missing, List<MissingItem> restocked, List<MissingItem> unfulfilled, boolean success
- Static factory methods:
  - success(List<MissingItem> restocked) - success=true, missing=restocked, unfulfilled=empty
  - partial(List<MissingItem> restocked, List<MissingItem> unfulfilled) - success=false
  - failed(List<MissingItem> missing, String reason) - success=false
- getMissing(), getRestocked(), getUnfulfilled(), isSuccess() getters
- getTotalMissing(), getTotalRestocked() convenience counts
- toString() for logging summary

ContainerType enum should be a nested enum inside MissingItem or separate file - prefer nested for cohesion.

Use defensive copies in constructors to prevent external mutation.
  </action>
  <verify>gradle :utilities:compileJava succeeds with no errors</verify>
  <done>MissingItem and RestockResult classes compile, provide clear API for tracking restock operations</done>
</task>

<task type="auto">
  <name>Task 2: Create LoadoutComparator for diff calculation</name>
  <files>utilities/src/main/java/utilities/loadout/LoadoutComparator.java</files>
  <action>
Create LoadoutComparator class that compares current state to loadout baseline:

**Constructor:**
- Takes ItemResolver for fuzzy matching support

**Main method:**
```java
public List<MissingItem> compare(Script script, Loadout loadout)
```

**Logic:**
1. Get current equipment via script.getWidgetManager().getEquipment()
2. For each non-null loadout equipment slot:
   - Check if equipped item matches (exact ID or fuzzy via ItemResolver.matchesLoadoutItem)
   - If missing entirely, add MissingItem with currentQuantity=0
   - If item doesn't match (wrong item equipped), treat as missing

3. Get current inventory via script.getWidgetManager().getInventory()
4. For each non-null loadout inventory item:
   - Search inventory for matching items (exact or fuzzy)
   - Calculate current quantity vs needed quantity based on mode:
     - EXACT: need exactly N, deficit = max(0, N - current)
     - UNLIMITED: always need more (treat as missing if not present, but no specific deficit)
     - MINIMUM: need at least N, deficit = max(0, N - current)
   - Add MissingItem only if deficit > 0 or UNLIMITED mode without item

5. Skip rune pouch, bolt pouch, quiver for v1 (focus on equipment + inventory)

**Key considerations:**
- Use ItemResolver.matchesLoadoutItem() for fuzzy matching on degradables
- Handle stackable vs non-stackable correctly (quantity vs slot count)
- Equipment slots are 1:1 (quantity always 1)
- Inventory can have multiple of same item across slots

Return empty list if nothing is missing.
  </action>
  <verify>gradle :utilities:compileJava succeeds with no errors</verify>
  <done>LoadoutComparator.compare() returns accurate list of missing items with correct deficit calculations based on quantity modes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] gradle :utilities:compileJava succeeds
- [ ] RestockResult has success/partial/failed factory methods
- [ ] MissingItem tracks container type, loadout item, and quantities
- [ ] LoadoutComparator handles EXACT, UNLIMITED, MINIMUM modes correctly
- [ ] Fuzzy matching uses ItemResolver for degradable equipment
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No compilation errors
- Classes follow existing utility patterns (defensive copies, immutable data)
</success_criteria>

<output>
After completion, create `.planning/phases/05-restock-logic/05-01-SUMMARY.md`
</output>
