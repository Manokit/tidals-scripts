---
phase: 04-import-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - utilities/src/main/java/utilities/loadout/LoadoutImporter.java
  - utilities/src/main/java/utilities/loadout/LoadoutExporter.java
autonomous: true
---

<objective>
Create JSON import/export utilities for loadouts.

Purpose: Enable users to import RuneLite Inventory Setups JSON and export extended format with quantity modes.
Output: LoadoutImporter and LoadoutExporter utility classes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# RuneLite format documentation (critical for import):
@TidalsBankTester/EXPORT_FORMAT.md

# Existing data model:
@utilities/src/main/java/utilities/loadout/Loadout.java
@utilities/src/main/java/utilities/loadout/LoadoutItem.java
@utilities/src/main/java/utilities/loadout/QuantityMode.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LoadoutImporter for RuneLite JSON</name>
  <files>utilities/src/main/java/utilities/loadout/LoadoutImporter.java</files>
  <action>
Create a LoadoutImporter class that parses RuneLite Inventory Setups JSON format.

Key mapping (from EXPORT_FORMAT.md):
- `setup.name` -> Loadout name
- `setup.inv` -> 28-slot inventory array (null = empty slot)
- `setup.eq` -> 14-slot equipment array (slots 11-13 are always empty in RuneLite)
- `setup.rp` -> rune pouch (null if not present)
- `setup.bp` -> bolt pouch (null if not present)
- `setup.qv` -> quiver (null if not present)

Item mapping:
- `id` -> itemId (required)
- `q` -> quantity (default 1 when null/omitted)
- `f` -> fuzzy (default false when null)
- `sc` -> stack compare (IGNORED - RuneLite highlighting only)

IMPORTANT: Equipment array is 14 slots in RuneLite but our Loadout uses 11 slots. Map indices:
- RuneLite 0-10 -> our 0-10 (head, cape, amulet, ammo, weapon, body, shield, legs, gloves, boots, ring)
- RuneLite 11-13 -> IGNORED (always empty filler slots)

Methods to implement:
- `static Loadout fromJson(String json)` - parse JSON string, return Loadout
- `private static LoadoutItem parseItem(JSONObject itemObj)` - parse single item
- `private static LoadoutItem[] parseItemArray(JSONArray arr, int expectedSize)` - parse item array

Use manual JSON parsing with org.json (already available in OSMB runtime):
- `new JSONObject(json)` to parse
- `obj.optJSONArray("inv")` for optional arrays
- `obj.optInt("id", -1)` for optional integers
- `obj.optBoolean("f", false)` for optional booleans

Handle edge cases:
- Null items in arrays = empty slot
- Missing quantity = 1
- Missing fuzzy = false
- Invalid JSON = throw IllegalArgumentException with message
</action>
  <verify>Create test JSON string with inventory, equipment, and rune pouch. Call LoadoutImporter.fromJson() and verify loadout has correct items.</verify>
  <done>LoadoutImporter.fromJson() correctly parses RuneLite Inventory Setups JSON into Loadout object with all containers populated.</done>
</task>

<task type="auto">
  <name>Task 2: Create LoadoutExporter for extended JSON</name>
  <files>utilities/src/main/java/utilities/loadout/LoadoutExporter.java</files>
  <action>
Create a LoadoutExporter class that exports loadouts to our extended JSON format.

Our format extends RuneLite format with:
- `mode` field on items (string: "exact", "unlimited", "minimum") - our addition for quantity modes
- Otherwise compatible with RuneLite for basic import

Export structure:
```json
{
  "setup": {
    "name": "loadout name",
    "inv": [{item}, null, ...],  // 28 slots
    "eq": [{item}, null, ...],   // 11 slots (we use 11, not RuneLite's 14)
    "rp": [{item}, ...] or null, // rune pouch
    "bp": [{item}, ...] or null, // bolt pouch
    "qv": [{item}] or null       // quiver
  }
}

Item structure:
{
  "id": 995,
  "q": 10000,        // omit if 1
  "f": true,         // omit if false
  "mode": "exact"    // omit if "exact" (our extension)
}
```

Methods to implement:
- `static String toJson(Loadout loadout)` - convert Loadout to JSON string
- `static String toJsonPretty(Loadout loadout)` - same but formatted with indentation
- `private static JSONObject exportItem(LoadoutItem item)` - export single item
- `private static JSONArray exportItemArray(LoadoutItem[] items)` - export item array

Optimization rules (match RuneLite style):
- Omit `q` if quantity == 1
- Omit `f` if fuzzy == false
- Omit `mode` if mode == EXACT (default)
- Use null for empty slots in arrays

Do NOT include RuneLite-only fields we don't use:
- `hc`, `hd`, `dc` (highlighting)
- `fb`, `uh` (filtering)
- `sb`, `fv`, `iId` (UI settings)
- `layout` array (bank layout)
- `afi` (additional filtered items)
- `sc` on items (stack compare)
</action>
  <verify>Create a Loadout with various items, export via LoadoutExporter.toJson(), verify output is valid JSON with correct structure.</verify>
  <done>LoadoutExporter.toJson() produces valid JSON with our extended format. Items have mode field when not EXACT. Output is compact (no unnecessary fields).</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] LoadoutImporter.fromJson() parses RuneLite example from EXPORT_FORMAT.md
- [ ] Equipment slot mapping correct (14 RuneLite -> 11 our slots)
- [ ] Null handling correct (missing fields use defaults)
- [ ] LoadoutExporter.toJson() produces valid JSON
- [ ] Round-trip works: export then import preserves data
- [ ] `gradle :utilities:build` succeeds
</verification>

<success_criteria>
- LoadoutImporter handles RuneLite Inventory Setups JSON format
- LoadoutExporter produces extended format with quantity modes
- Both classes handle all containers (equipment, inventory, pouches)
- No new dependencies (uses org.json from OSMB runtime)
</success_criteria>

<output>
After completion, create `.planning/phases/04-import-export/04-01-SUMMARY.md`
</output>
