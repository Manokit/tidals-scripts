---
phase: 01-data-model
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - utilities/src/main/java/utilities/loadout/QuantityMode.java
  - utilities/src/main/java/utilities/loadout/LoadoutItem.java
  - utilities/src/main/java/utilities/loadout/Loadout.java
autonomous: true
---

<objective>
Define core data model types for loadout management - LoadoutItem, QuantityMode, and Loadout container.

Purpose: Establish the foundation for all loadout functionality. These types will be used by the editor UI, import/export, restock logic, and script integration.
Output: Three new classes in utilities/src/main/java/utilities/loadout/ package.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# existing utility patterns to follow
@utilities/src/main/java/utilities/WithdrawalRequest.java

# runelite export format for field mapping
@TidalsBankTester/EXPORT_FORMAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QuantityMode enum</name>
  <files>utilities/src/main/java/utilities/loadout/QuantityMode.java</files>
  <action>
Create enum with three modes:
- EXACT: restock to exactly N items (e.g., 10k coins for ship fee)
- UNLIMITED: take entire stack from bank (runes, bolts, arrows) - represented as * in UI
- MINIMUM: must have at least N, fail restock check if not (e.g., >50 ruby bolts) - represented as > in UI

Include:
- Javadoc explaining each mode's purpose
- symbol field storing the UI representation ("", "*", ">")
- getSymbol() method
- fromSymbol(String) static factory for parsing UI input

Follow existing enum patterns in codebase (UPPER_CASE values, PascalCase type).
  </action>
  <verify>Compiles with `cd /Users/zaffre/Documents/Engineering/Projects/Scripts-Project/tidals-scripts && JAVA_HOME=$(/usr/libexec/java_home -v 17) gradle :utilities:compileJava`</verify>
  <done>QuantityMode.java exists with EXACT, UNLIMITED, MINIMUM values and symbol parsing methods</done>
</task>

<task type="auto">
  <name>Task 2: Create LoadoutItem class</name>
  <files>utilities/src/main/java/utilities/loadout/LoadoutItem.java</files>
  <action>
Create immutable data class representing a single item in a loadout slot:

Fields:
- int itemId: OSMB/RuneLite item ID (required)
- String name: human-readable name for display (can be null, resolved later)
- int quantity: amount required (default 1)
- QuantityMode mode: how to interpret quantity (default EXACT)
- boolean fuzzy: if true, match potion doses, jewelry charges, degraded variants (default false)

Include:
- Constructor taking all fields
- Builder pattern for fluent construction: LoadoutItem.builder().itemId(995).quantity(10000).build()
- Getters for all fields
- equals/hashCode based on itemId only (same item ID = same item regardless of quantity)
- toString() returning "itemId:quantity" or "itemId:quantity*" for unlimited

Map to RuneLite format fields:
- id -> itemId
- q -> quantity (default 1 when null)
- f -> fuzzy (default false when null)
- sc -> not stored (RuneLite highlighting only, not needed for restocking)

Do NOT include sprite/image data - that's Phase 2 (Item Resolution).
  </action>
  <verify>Compiles with `cd /Users/zaffre/Documents/Engineering/Projects/Scripts-Project/tidals-scripts && JAVA_HOME=$(/usr/libexec/java_home -v 17) gradle :utilities:compileJava`</verify>
  <done>LoadoutItem.java exists with all fields, builder pattern, and proper equals/hashCode</done>
</task>

<task type="auto">
  <name>Task 3: Create Loadout container class</name>
  <files>utilities/src/main/java/utilities/loadout/Loadout.java</files>
  <action>
Create class aggregating all container slots for a complete loadout:

Fields:
- String name: loadout name (required)
- LoadoutItem[] equipment: 14 slots (indices per EXPORT_FORMAT.md: 0=head, 1=cape, 2=amulet, 3=ammo, 4=weapon, 5=body, 6=shield, 7=legs, 8=gloves, 9=boots, 10=ring, 11-13=unused)
- LoadoutItem[] inventory: 28 slots
- LoadoutItem[] runePouch: 4 slots (nullable - no rune pouch)
- LoadoutItem[] boltPouch: 4 slots (nullable - no bolt pouch)
- LoadoutItem[] quiver: 1 slot (nullable - no quiver)

Include:
- Constructor initializing arrays to correct sizes with null elements
- Setters for individual slots: setEquipment(int slot, LoadoutItem item)
- Getters returning defensive copies: getEquipment() returns new array copy
- Convenience methods:
  - getEquipmentSlot(int slot): get single slot
  - setInventorySlot(int slot, LoadoutItem item)
  - getInventorySlot(int slot)
  - hasRunePouch(): returns runePouch != null
  - hasBoltPouch(): returns boltPouch != null
  - hasQuiver(): returns quiver != null
- getAllItems(): returns flat List<LoadoutItem> of all non-null items across all containers (for restock logic)

Equipment slot constants as static final int fields:
- SLOT_HEAD = 0, SLOT_CAPE = 1, SLOT_AMULET = 2, SLOT_AMMO = 3, SLOT_WEAPON = 4
- SLOT_BODY = 5, SLOT_SHIELD = 6, SLOT_LEGS = 7, SLOT_GLOVES = 8, SLOT_BOOTS = 9, SLOT_RING = 10

Array sizes as constants:
- EQUIPMENT_SIZE = 14, INVENTORY_SIZE = 28, RUNE_POUCH_SIZE = 4, BOLT_POUCH_SIZE = 4, QUIVER_SIZE = 1
  </action>
  <verify>Compiles with `cd /Users/zaffre/Documents/Engineering/Projects/Scripts-Project/tidals-scripts && JAVA_HOME=$(/usr/libexec/java_home -v 17) gradle :utilities:compileJava`</verify>
  <done>Loadout.java exists with all containers, slot constants, and getAllItems() method</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All three classes compile without errors
- [ ] Package structure is utilities/src/main/java/utilities/loadout/
- [ ] QuantityMode has all three modes with symbol parsing
- [ ] LoadoutItem has builder pattern working
- [ ] Loadout has correct array sizes and slot constants
- [ ] Full utilities build: `cd /Users/zaffre/Documents/Engineering/Projects/Scripts-Project/tidals-scripts && JAVA_HOME=$(/usr/libexec/java_home -v 17) gradle :utilities:build`
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Data model matches RuneLite format structure for future import compatibility
- Classes are immutable/defensive where appropriate
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-model/01-01-SUMMARY.md`
</output>
